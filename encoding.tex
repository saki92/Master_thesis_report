\section{Encoding of the \acl{bpl} Codes}\label{sec:encode}
In this section, we discuss how the encoder for \ac{bpl} codes is designed and how the termination is handled. In some places of this section, we use examples of \acp{ldpccc} with small $L$ and $m_s$ as the \ac{bpl} codes are too large to be represented on paper.

\subsection{Encoder Design}\label{sec:enc_design}
Encoding algorithms are simpler than decoding algorithms because there exists no uncertainty in the output bits of an encoder. The encoding of \ac{bpl} codes is done in the following steps:
\begin{enumerate}
  \item The information bits are divided into several \acp{cb} and copied into the output buffer of the encoder. An example of this step for a code with $R_\infty=2/3$ is shown in Figure~\ref{fig:encode_copy}.
  \begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth, height=\textwidth]{graphics/encoder_copy}
    \caption{Copy input bits to output buffer. The shaded box represents the position of the parity bits.}
    \label{fig:encode_copy}
  \end{figure}
  \item The parity bits are generated by performing addition modulo 2 with all bits (both information and parity bits) in the output buffer according to the parity-check polynomials of the code. An example of the parity-bit generation of a code with $R_\infty=2/3$ is shown in Figure~\ref{fig:encoder_paritygen}.
   \begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth, height=\textwidth]{graphics/encoder_parity}
    \caption{Generation of the last parity bit. Note: Only for representative purpose.}
    \label{fig:encoder_paritygen}
  \end{figure}
  \item The termination sequence is appended to the output buffer of the encoder and is discussed in Section~\ref{sec:bpl_termi} in detail.
\end{enumerate}

\subsection{Termination Sequence}\label{sec:bpl_termi}
The objective of terminating any \ac{ldpccc} is to have a finite codeword length. Termination essentially means truncating the \ac{pcm}. To satisfy the last $m_s$ parity checks, an appropriate termination sequence must be appended to the codeword. To find the appropriate termination sequence, one must solve a system of linear equations because the usual encoding procedure satisfies only the first parity check and not the remaining $m_s-1$ parity checks.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth, height=\textwidth]{graphics/term_solve}
  \caption{The last part of a \ac{pcm} of an example \ac{ldpccc} code with $R_\infty=2/3$ and $m_s=4$. Depicted above the \ac{pcm} is the last part of the codeword vector.}
  \label{fig:bpl_term}
\end{figure}

The \ac{pcm} in (\ref{eq:bpl_pcm}) of a \ac{bpl} code has a structure as shown in Figure~\ref{fig:bpl_term} where $\mathbf{e}\in\mathbb{F}_2^{m_sn\times 1}$ is the last part of the codeword vector. Vector $\mathbf{a}\in\mathbb{F}_2^{l_t\times 1}$ is the termination sequence that should be determined and appended to the end of $\mathbf{e}$. All the rows of the matrix $[\mathbf{P},\mathbf{D}]$ are the parity checks that are targeted to be satisfied by the termination sequence. Hence, provided a correct termination sequence $\mathbf{a}$, the following equations from~\cite{Chen2006} hold true.
\begin{align}
\begin{bmatrix}\mathbf{P} &\mathbf{D}\end{bmatrix}\odot
\begin{bmatrix}
\mathbf{e}\\
\mathbf{a}
\end{bmatrix}&=\mathbf{0}\\
\mathbf{P}\odot\mathbf{e}&=\mathbf{D}\odot\mathbf{a}
\end{align}
The termination sequence is given by
\begin{align}\label{eq:term_sol}
\mathbf{a}=\mathbf{D}^{-1}\odot\mathbf{P}\odot\mathbf{e}.
\end{align}
The maximum length $l_t$ of the termination sequence $\mathbf{a}$ should not exceed the one given in the \ac{bpl} standard. However, a shorter termination sequence with $l_t\geq n$ can be chosen such that $\mathbf{D}$ is a square matrix. Once the termination sequence $\mathbf{a}$ is determined from equation (\ref{eq:term_sol}), it is appended to the codeword and the remaining part of the termination sequence (if any) is filled with zeros. These zeros do not contribute to any parity checks. For an encoder that is implemented on hardware, these zeros are required to bring the encoder to an all-zero state. But we omit these zeros since we do software implementation. Hence, the resulting \ac{pcm} and codeword looks like the one shown in Figure~\ref{fig:bpl_term} with no zeros at the end of the codeword and without their corresponding edges in the \ac{pcm}.
%\begin{figure}[htbp]
%  \centering
%  \includegraphics[width=\textwidth, height=\textwidth]{graphics/term_result}
%  \caption{The last part of the \ac{pcm} and codeword after adding the actual termination sequence.}
%  \label{fig:term_res}
%\end{figure}

Unfortunately, we found that a proper termination sequence cannot be computed for \ac{bpl} codes. It is found through numerical evaluations that $\mathbf{D}$ is not full-rank and hence its inverse do not exist. A full rank $\mathbf{D}$ matrix is possible if $\mathbf{D}\in\mathbb{F}_2^{r\times c}$ and $r>c$. But with the help of numerical solvers, we found that the solution for such an overdetermined system do not exist either. Hence, a termination sequence to satisfy the last $m_s$ parity checks cannot be found for \ac{bpl} codes. So we choose to omit the last $m_s$ parity checks from the \ac{pcm} and do the termination by \emph{zero-tailing} as mentioned in the standard.

The steps for performing zero-tailing termination are as follows.
\begin{enumerate}
  \item The $n_z$ zero-tail bits are appended to the input buffer of the encoder after the $n_m$ information bits.
  \item The encoding as mentioned in Section~\ref{sec:enc_design} is performed to all the information bits and zero-tail bits.
\end{enumerate}
With the zero-tail-termination, the zero-tail bits are always known at the receiver. Hence, the zero-tail bits are not transmitted in an actual transmission system. Only the parity bits generated from the zero-tail bits are transmitted.

The zero-tail-termination does not satisfy the last $m_s$ parity checks of the \ac{pcm}. Hence, the \ac{pcm} of a zero-tail-terminated \ac{bpl} codes looks like the one shown in Figure~\ref{fig:pcm_zero}.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth, height=\textwidth]{graphics/term_zero}
  \caption{The last part of the \ac{pcm} and codeword after adding the zero-tailing termination sequence.}
  \label{fig:pcm_zero}
\end{figure}

The \ac{pcm} of the zero-tail-terminated codes have the same \ac{cn} degrees in the middle and in the end. But in contrast, properly terminated codes have lower \ac{cn} degrees at the end. This reduces the performance of the codes as lower \ac{cn} degree means better reliability of the variable nodes connected to them. Since the zero-tail bits are known at the receiver, they improve the reliability of the connected \acp{vn} during the decoding process.