\chapter{Decoding Improvements}\label{ch:dec_improve}
In this chapter, we discuss the techniques that are investigated in this thesis to improve the decoding performance. We start with the discussion of existing techniques that improve the decoding performance. We then discuss the techniques investigated in this thesis and possible areas of further research and improvements. We finish this section by discussing the results from our simulations.

\section{Existing Techniques and Motivation}
Improvement techniques for window decoding of \gls{ldpccc} are being widely discussed in literatures. An attractive technique that we found in the literature is the \emph{Zigzag decoder} proposed in~\cite{Shadi2015}. In a normal window decoder, the window moves from left to right of the \gls{pcm}. So, the messages pass from left to right of the codeword. The \glspl{vn} in the left and right ends of the codeword are more reliable than that are in the middle. The Zigzag decoder moves the window from right to left of the \gls{pcm} within a small part where the \glspl{vn} are not decoded. This allows the messages to pass from right to left of the codeword and hence influencing the high reliability of the \glspl{vn} in the right on the \glspl{vn} in the left.

The Zigzag decoder performs better than the conventional left to right decoder but the decoding complexity in terms of number of iterations are higher. The implementation complexity is also high due to the nature of the decoder. Hence, this motivates us to develop a technique to utilize the high reliability of \glspl{vn} in right of the codeword while have similar decoding and implementation complexity as the conventional window decoder.

Another improvement technique that we found to be interesting is the \emph{early-success} technique in which the decoding stops before reaching the maximum number of iterations $I$. Although its very natural to stop decoding when the target \gls{vn} are decoded, one should carefully choose an optimum criterion for deciding whether the target \gls{vn} are decoded. A heuristic choice is to check whether the \emph{target-\glspl{cn}} i.e., the \glspl{cn} connected to the target \glspl{vn} are fulfilled. A new early-success criterion was proposed in~\cite{Kang2018} based on reliable \glspl{vn} and is called \gls{psc}. They distinguish the \glspl{vn} inside the window as \emph{complete-\glspl{vn}} and \emph{incomplete-\glspl{vn}}. Complete-\glspl{vn} are \glspl{vn} whose connected \glspl{cn} are completely inside the window. The remaining \glspl{vn} in the window are called the incomplete-\glspl{vn}. This is illustrated in Figure~\ref{fig:comp_vn}. The authors say that the complete-\glspl{vn} are more reliable than the incomplete ones as they get updates from all their connected \glspl{cn}. Hence, correctness on only the complete-\glspl{cn} i.e., the \glspl{cn} connected to only the complete-\glspl{vn} are considered as early-success criterion.

Although the \gls{psc} rule proposed in~\cite{Kang2018} reduces the number of iterations with same performance, they are suitable only for small windows where $W<2(m_s+1)$. For larger window sizes, the number complete-\glspl{vn} are greater than the number of incomplete-\glspl{vn}. This also makes the number of complete-\glspl{cn} to be grater than the number of target-\glspl{cn}. So for larger windows, the \gls{psc} rule actually increases the number of iterations. This motivates us develop a better early-success criterion that depends on the window size.

\section{Base Decoder Configuration}
Before discussing the details of the techniques used in the improved decoder, it is essential to define a decoder configuration to which the improvements are made. This allows better understanding of the techniques and evaluation of the simulation results. Let us call the decoder without out improvements as \gls{bd} and the one with our improvements as \gls{id}. The \gls{bd} uses the \gls{wd} technique to decoder the \gls{bpl} codes. The window slides from the left end of the \gls{pcm} to the right end. Within each window, serial scheduling is performed by updating the \glspl{cn} from top to bottom for a maximum of $I_{\text{max}}$ iterations.

In the last window instance i.e., when the window touches the right most column of the \gls{pcm}, all the \glspl{vn} inside the window are considered as target \glspl{vn}. Hence, the early success criterion is to check if all \glspl{cn} inside the window are fulfilled. This idea was proposed in~\cite{Ali2018} with flooding schedule. We adapt this technique in our \gls{bd} to minimize the total number to iterations.

An early success technique is used in our \gls{bd}. This technique prevents the decoder from exhausting all iteration in a window if the target \glspl{vn} are decoder before reaching the maximum number of iteration. Thus saving computational effort. The criterion for finding the correctness of the target \glspl{vn} is to check if all the \glspl{cn} connected to the target \glspl{vn} fulfill their parity-checks.

We now know that the \gls{bpl} codes are terminated using the zero-tail termination technique. The zero-tail bits and their positions are always known at the receiver. Hence, the \glspl{llr} of these bits are made to $+\infty$ which indicates that these bits most certainly have the value 0.

The configurations of the \gls{bd} is summarized below.
\begin{enumerate}
  \item \gls{bp} based window decoder and the window moves from left to right.
  \item Maximum number of iterations for each window is $I_{\text{BD}}$.
  \item Serial scheduling with top to bottom \gls{cn} update order.
  \item In the last window, all \glspl{vn} are considered as target \glspl{vn}.
  \item Target \glspl{cn} are considered as early-success criterion.
\end{enumerate}

\section{\acrfull{lrl} \acrfull{wd}}
In this thesis, we propose the \emph{\gls{lrl} decoder}. The \gls{lrl} decoder moves the window from left to right and from right to left of the \gls{pcm} unlike the \gls{bd} that moves the window only from left to right. As already mentioned earlier, the \glspl{vn} in the left and right of the codeword are more reliable than the \glspl{vn} in the middle due to the lower \gls{cn} degrees in both the ends. This can be seen in Figure~\ref{fig:indiv_ber} which plots the individual probability of error for all the bits in the codeword. We can see that the bits in the left and right of the codeword have lower probability of error than the bits in the middle. During the first half decoding phase of the \gls{lrl} decoder, the window moves from the first window position to the last window position of the \gls{pcm}. During the second phase of the decoding i.e., after decoding the last window position, the window moves to the left till it reaches the first window position. This is illustrated in Figure~\ref{fig:pcm_lrl}.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.9\linewidth]{plots/indiv_ber}
  \caption{Probability of error for each bit in the codeword of a code with $R_\infty=2/3$, $n_i=3500$. Termination bits are excluded.}
  \label{fig:indiv_ber}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.5\textwidth, height=0.2\textwidth]{graphics/pcm_lrl}
  \caption{\gls{pcm} illustrating \gls{lrl} decoder.}
  \label{fig:pcm_lrl}
\end{figure}
So during the first decoding phase, the \glspl{vn} in the left increases the reliability of the \glspl{vn} to the right as the window moves forward. Then during the second decoding phase, the better \glspl{vn} in the right of the codeword increase the reliability of the \glspl{vn} to the left as the window moves backwards. The maximum number of iterations within each window is half of the maximum number of iterations in the \gls{bd} i.e., $I_{\text{LRL}}=I_{\text{BD}}/2$. This is done to maintain the same decoding complexity as the \gls{bd} because each window in the \gls{lrl} decoder is decoded twice.

With the \gls{lrl} decoder, we propose two different configurations of windows. They are illustrated in Figure~\ref{fig:win_config_lrl}. The red box indicates the window. The figure to the left shows a window configuration where the left most \glspl{vn} (blue hatched) are the target \glspl{vn}. The order of \gls{cn} update is from top to bottom as one indicated by the brown arrow. Let us call this \gls{lrl} configuration-\rom{1}. The illustration to the right of the Figure~\ref{fig:win_config_lrl} shows that the right most \glspl{vn} in the window are the target \glspl{vn}. The order of \gls{cn} update is from bottom to top as indicated by the brown arrow. Let us call this \gls{lrl} configuration-\rom{2}.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.5\textwidth, height=0.2\textwidth]{graphics/win_config_lrl_new}
  \caption{Different window configurations used in \gls{lrl} decoder. Left image illustrates \gls{lrl} configuration-\rom{1} and right image illustrates \gls{lrl} configuration-\rom{2}.}
  \label{fig:win_config_lrl}
\end{figure}

We discuss the performance of the \gls{lrl} decoder with both configurations. First we use \gls{lrl} configuration-\rom{1} in both phases of the \gls{lrl} decoder. When \gls{lrl} configuration-\rom{1} is used in the second phase, the window iterates for more number iterations than when \gls{lrl} configuration-\rom{2} is used. This is because the target \gls{vn} are at the end of the window corresponding to the window direction.

Then we use the \gls{lrl} configuration-\rom{1} during the first phase and \gls{lrl} configuration-\rom{2} during the second phase. During the second phase the \gls{cn} updates are done from bottom to top to increase the effect of high reliability of \glspl{vn} in the right on to the \glspl{vn} in the middle. The simulation results of both the configurations are evaluated in Chapter~\ref{ch:simulation}.

\section{\acrfull{ipsc}}
The next technique we propose is the \gls{ipsc} rule. As mentioned earlier, a \gls{psc} was proposed in~\cite{Kang2018} that uses only complete-\gls{cn} as early-success criterion. In the \gls{ipsc} rule, we introduce an additional early-success rule for $W>2(m_s+1)$. That is, when the window size $W>2(m_s+1)$ the target \gls{cn} are considered as early-success criterion. This could reduce the number of iterations or edge updates because for $W>2(m_s+1)$ the number of complete-\gls{cn} are greater than the number of target \gls{vn} and so the window could converge sooner. A window is said to have converged when the target \gls{vn} are decoded. Table~\ref{tab:ipsc} summarizes the \gls{ipsc} technique. The simulation results of the \gls{ipsc} are evaluated in Chapter~\ref{ch:simulation}.
\begin{figure}[htbp]
  \centering
  %\tikzsetnextfilename{tanner_graph}
  \includegraphics[width=0.5\textwidth, height=0.2\textwidth]{graphics/comp_vn}
  \caption{\gls{pcm} illustrating complete-\glspl{vn}, incomplete-\glspl{vn} and complete-\glspl{cn}.}
  \label{fig:comp_vn}
\end{figure}

\begin{table}[htbp]
\centering
\begin{tabular}{|l|l|l|}
  \hline
  \textbf{S.No.} &\textbf{Window Size} &\textbf{Early-success Criterion}\\
  \hline
  \hline
  1. &$W\leq2(m_s+1)$ &Complete-\glspl{vn}.\\
  \hline
  2. &$W>2(m_s+1)$ &Target \glspl{vn}.\\
  \hline
\end{tabular}
\caption{Early-success criteria for \gls{ipsc}}
\label{tab:ipsc}
\end{table}